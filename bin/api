#!/bin/bash

# Requests a web API resource and pretty prints resulting JSON.

usage()
{
    echo "usage: ${0##*/} [options] [curl options] 'URI'"
    echo ""
    echo "Hits the given URI and returns the result as prettified JSON."
    echo "options:"
    echo "    -h: show this usage help"
    echo "    -n: dry run"
    echo "    -j: use curl option: -H 'content-type: application/json'"
    echo ""
    echo "curl options:"
    echo "The first option that can not be parsed as an option to this script"
    echo "will be interpreted as the beginning of options to be passed to curl."
    echo "Or force the beginning of curl option parsing by passing -- first."
    exit 1
}

OPT_DRYRUN=0
OPT_APPJSON=0
IGNORE_BAD_OPT=0
while getopts "hnj" opt 2>/dev/null; do
    case "$opt" in
        h) usage;;
        n) OPT_DRYRUN=1;;
        j) OPT_APPJSON=1;;
        \?) IGNORE_BAD_OPT=1;;
    esac
done
shift $((OPTIND - 1 - IGNORE_BAD_OPT))

args=("$@")
query="${args[${#args[@]} - 1]}"
unset args[${#args[@]}-1] # pop query off end of args
curl_opts="${args[*]}"

curl_cmd="curl --silent --show-error $curl_opts"
[[ $OPT_APPJSON == 1 ]] && curl_cmd="$curl_cmd -H 'content-type: application/json'"
python_cmd="python -mjson.tool"
pygmentize_cmd="pygmentize -l json -f terminal256"

cleanup_api()
{
    [[ -n "$curl_output" ]] && rm -f "$curl_output"
    [[ -n "$time_output" ]] && rm -f "$time_output"
    [[ -n "$python_output" ]] && rm -f "$python_output"
    [[ -n "$pygmentize_output" ]] && rm -f "$pygmentize_output"
}

abort_api()
{
    if [[ -n "$1" ]]; then
        echo $'\n'"$(tput bold)error: $curl_cmd$(tput sgr0)"
        cat "$1" >&2
    fi

    if [[ -n "$2" ]]; then
        echo $'\n'"$(tput bold)error: $python_cmd$(tput sgr0)"
        cat "$2" >&2
    fi

    if [[ -n "$3" ]]; then
        echo $'\n'"$(tput bold)error: $pygmentize_cmd$(tput sgr0)"
        cat "$3" >&2
    fi

    cleanup_api

    exit 1
}

let token_count=0
IFS='?&' read -ra arr <<< "$query"
for token in "${arr[@]}"; do
    let token_count=$((token_count + 1))
    if [[ $token_count == 1 ]]; then
        curl_cmd="$curl_cmd '$token'" # url
        continue
    fi
    curl_cmd="$curl_cmd --data-urlencode '$token'" # params
done
echo $'\n'"$curl_cmd | $python_cmd | $pygmentize_cmd" >&2

[[ $OPT_DRYRUN == 1 ]] && exit 0

curl_output=$(mktemp -t tmp.XXXXXXXXXX.curl.log)
trap 'rm -f $curl_output' EXIT

time_output=$(mktemp -t tmp.XXXXXXXXXX.time.log)
trap 'rm -f $time_output' EXIT

timed_cmd=$"time $curl_cmd"
bash -c $"$timed_cmd" >"$curl_output" 2>"$time_output" # time command sends output to stderr

if [[ $? != 0 ]]; then
    # Due to the way redirection is set up here, time_output will contain
    # the curl error message (as well as any relevant time output) when
    # the evaluation of timed_cmd fails.
    abort_api "$time_output"
fi

python_output=$(mktemp -t tmp.XXXXXXXXXX.python.log)
trap 'rm -f $python_output' EXIT

eval "$python_cmd" <"$curl_output" >"$python_output" 2>&1
if [[ $? != 0 ]]; then
    abort_api "$curl_output" "$python_output"
fi

if [[ -t 1 ]] ; then
    pygmentize_output=$(mktemp -t tmp.XXXXXXXXXX.pygmentize.log)
    trap 'rm -f $pygmentize_output' EXIT

    eval "$pygmentize_cmd" <"$python_output" >"$pygmentize_output" 2>&1
    if [[ $? != 0 ]]; then
        abort_api "$curl_output" "$python_output" "$pygmentize_output"
    fi
    echo
    sed 's/\\"/"/g' < "$pygmentize_output" | sed "s/\\n/\
    /g"
else
    sed 's/\\"/"/g' <"$python_output" | sed "s/\\n/\
    /g"
fi

cat "$time_output" >&2

cleanup_api
