#!/bin/bash

# Installs development environment on OS X machines.

################################################################################
# Settings
################################################################################

HOMEBREW_FORMULAS="autoconf boost cmake coreutils cppunit dmd doxygen fontconfig \
    freetype ghostscript git gnu-sed imagemagick jbig2dec jpeg libevent yaml-cpp \
    libpng libtiff libtool libyaml little-cms2 maven memcached mercurial mongodb \
    ncftp node openssl ossp-uuid pcre pidof pkg-config plotutils postgresql wget \
    readline ruby s3cmd scons spark sqlite unixodbc unrar watch xz libmpc geoip  \
    shellcheck tree youtube-dl sloccount jhead pandoc caskroom/cask/brew-cask"

HOMEBREW_CASKS="google-chrome pdftk"

PIP_PACKAGES="bson pymongo fabric iniparse psycopg2 oauth2client pytz suds       \
    google-api-python-client httplib2 tinycss termcolor requests uritemplate     \
    beautifulsoup4 pyflakes pep8 flake8"

CONDA_PACKAGES="dateutil pyzmq argcomplete"

GEM_PACKAGES="cap_gun archive-tar-minitar bson bson_ext bundler bundler-unload   \
    childprocess cuba erector gem-wrappers jekyll jewelbox log4r lolcat mongo    \
    net-ldap rack rack-protection railsless-deploy rubygems-bundler rvm shotgun  \
    yajl-ruby capistrano"

################################################################################
# Utilities
################################################################################
usage()
{
    echo "usage: ${0##*/} [-l|-d|-f|-h|--help] [all|step-name]" >&2
    echo "Automatically installs and configures a complete OS X developer environment." >&2
    echo "" >&2
    echo "options:" >&2
    echo "    -h, --help: show usage help" >&2
    echo "    -l: list available step names" >&2
    echo "    -d: dry-run" >&2
    echo "    -f: force install, do not ask for any confirmation" >&2
    echo "    all: executes all steps" >&2
    echo "    step-name: execute only the given step" >&2
    echo "" >&2
    echo "steps:" >&2
    "$0" -l | sed 's/^/    /g' >&2
    echo "" >&2
    echo "Homebrew Formulas: $(echo "$HOMEBREW_FORMULAS" | sed "s/  */, /g" | fold -w 80 -s)" >&2
    echo "" >&2
    echo "Homebrew Casks: $(echo "$HOMEBREW_CASKS" | sed "s/  */, /g" | fold -w 80 -s)" >&2
    echo "" >&2
    echo "Pip Packages: $(echo "$PIP_PACKAGES" | sed "s/  */, /g" | fold -w 80 -s)" >&2
    echo "" >&2
    echo "Conda Packages: $(echo "$CONDA_PACKAGES" | sed "s/  */, /g" | fold -w 80 -s)" >&2
    echo "" >&2
    echo "Gem Packages: $(echo "$GEM_PACKAGES" | sed "s/  */, /g" | fold -w 80 -s)" >&2
    exit 1
}

source "$HOME/.shell_control" || echo "$(tput bold)error: ~/.shell_control not installed!$(tput sgr0)" >&2

################################################################################
# Steps
################################################################################
step_setup_xcode() # xcode
{
    export SELECT="select"
    if [[ -z "$(which xcode-$SELECT)" ]]; then
        abort "install Xcode Command Line Tools first"
    fi
    if run "cc --version 2>/dev/null 1>&2"; then
        show "Xcode agreement is accepted."
    else
        show "Xcode agreement not accepted..."
        run "sudo cc --version" || abort "Xcode agreement NOT accepted"
    fi
    show "Xcode Command Line Tools properly installed."
}

step_check_java() # java
{
    show "Checking if java's installed..."
    run "java -version"
}

step_check_homebrew() # checkbrew
{
    diff <(echo "$HOMEBREW_FORMULAS" \
        | sort -u \
        | tr ' ' '\n') <(brew ls -1 \
        | sort -u) \
        | grep '[<>]' \
        | sort -u \
        | sed "s@^>@added:  @g;s@<@missing:@g" \
        | egrep -v "^missing:\s*openssl\$|^missing:\s*readline\$^missing:\s*sqlite\$"
            # we expect openssl, readline, and sqlite to be unlinked
}

install_brew_formula()
{
    if ! brew ls | grep -q "$1"; then
        run "brew install '$1'"
    else
        show "brew formula '$1' already installed"
    fi

    # force link the most recent versions
    run "brew unlink $1 && brew link --force --overwrite $1"
}

install_brew_cask()
{
    if ! brew ls | grep -q "$1"; then
        run "brew cask install  '$1'"
    else
        show "brew formula '$1' already installed"
    fi
}

ensure_homebrew_updated()
{
    if [[ -z "$(which brew)" ]]; then
        abort "please install Homebrew first"
    fi

    run "brew update"
    run "brew upgrade"
}

step_install_homebrew() # brew
{
    if [[ -z "$(which brew)" ]]; then
        show "installing homebrew..."
        run "ruby -e \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\""
        export PATH="$PATH:/usr/local/bin" # make sure brew is in your PATH before continuing
    else
        show "Homebrew already installed"
    fi

    if [[ -z "$(which brew)" ]]; then
        abort "failed to install Homebrew"
    fi

    ensure_homebrew_updated

    IFS=$" "
    for I in $HOMEBREW_FORMULAS; do
        install_brew_formula "$I"
    done
    for I in $HOMEBREW_CASKS; do
        install_brew_cask "$I"
    done

    # cmake's bundling utility fails in completely reasonable cases, the following steps are necessary
    run "chmod +w /usr/local/Cellar/freetds/*/lib/*.dylib 2>/dev/null"
    run "chmod +w /usr/local/Cellar/pcre/*/lib/*.dylib 2>/dev/null"

    # install glibtool and glibtoolize as the defaults
    run "ln -sf /usr/local/bin/glibtool /usr/local/bin/libtool"
    run "ln -sf /usr/local/bin/glibtoolize /usr/local/bin/libtoolize"

    # install the git remote-hg helper
    run "ln -sf $(brew ls -v git | grep git-remote-hg) /usr/local/bin"

    # unlink keg-only formulas which should not be not symlinked into /usr/local
    run "brew unlink openssl readline sqlite"

    # cleanup
    run "brew cleanup"
    run "brew cask cleanup"
}

step_install_python() # python
{
    # enter existing anaconda environment if it's detected
    [[ -d "$HOME/anaconda/bin" ]] && export PATH="$HOME/anaconda/bin:$PATH"

    if run "type conda >/dev/null 2>&1"; then
        run "conda update --yes --prefix \"$HOME/anaconda\" anaconda"
    else
        curl_output=$(mktemp -d -t tmp.XXXXXXXXXX)
        trap 'rm -rf $curl_output' EXIT

        latest="http://repo.continuum.io/archive/$(curl -s http://repo.continuum.io/archive/index.html \
            | grep MacOSX-x86_64.sh \
            | perl -nl -e 'm@<a.*? href="(.+)">(.+)</a@ig; print "$2\0$1"' \
            | sort -nr \
            | head -n 1 \
            | cut -d '' -f2 \
            | sed 's@./@@')"
        show "downloading $latest ..."
        run "curl -o \"$curl_output/anaconda.sh\" \"$latest\""
        run "bash \"$curl_output/anaconda.sh\" -b"

        # enter anaconda environment now that it's installed
        export PATH="$HOME/anaconda/bin:$PATH"

        run "conda config --set changeps1 no" # prevent conda from setting my PS1
        run "rm -f \"$HOME/Desktop/Launcher.app\"" # get rid of Launcher.app on Desktop

        run "rm -rf \"$curl_output\""
    fi

    # Install python packages that don't come with Anaconda... yet!
    IFS=$" "
    for I in $PIP_PACKAGES; do
        run "pip install -U $I"
    done

    # Install conda packages that don't come pre-installed with Anaconda
    for I in $CONDA_PACKAGES; do
        run "conda install -f --yes $I"
        run "conda update -f --yes $I"
    done

    # Fix annoying ipython settings
    run "ipython profile create"
    run "perl -pi -e 's/.*confirm_exit.*/c.TerminalInteractiveShell.confirm_exit = False/' $HOME/.ipython/profile_default/ipython_config.py"
    run "perl -pi -e 's/.*display_banner.*/c.TerminalIPythonApp.display_banner = False/' $HOME/.ipython/profile_default/ipython_config.py"
}

step_install_gem() # gem
{
    run "yes | sudo gem install rubygems-update"
    run "yes | sudo update_rubygems"
    run "yes | sudo gem update -q --system"

    IFS=$" "
    for I in $GEM_PACKAGES; do
        run "yes | sudo gem update -q $I"
        if ! gem list "$I" | grep -q "$I"; then
            run "yes | sudo gem install -q $I"
        fi
    done
}

step_install_xquartz() # xquartz
{
    if type Xquartz >/dev/null 2>&1; then
        show "a Xquartz is already installed..."
        ask "Force re-install?"
        [[ "$REPLY" == "y" ]] || return
    fi

    # assuming the last file that's not alpha, beta, or rc is the latest xquartz installer
    local latest="$(curl -s "http://xquartz-dl.macosforge.org/SL/" \
        | grep ".dmg<" \
        | sed 's@^.*>XQuartz@XQuartz@g' \
        | sed 's@\(XQuartz-[^<]*\)</a></td><td[^>]*>\([^<]*\).*@\1@g' \
        | egrep -v "beta|alpha|_rc" \
        | tail -n 1)"
    show "found latest XQuartz as \"$latest\""

    local tempdir="$(mktemp -d -t tmp.XXXXXXXXXX)" || abort "can't create temp directory"
    local cleanup="umount /Volumes/$(basename "$latest" .dmg); rm -rf $tempdir"
    run "cd $tempdir" || abort "can't enter temp directory" "$cleanup"
    if [[ ! -f "/tmp/.install_dev/$latest" ]] ; then
        run "wget -c http://xquartz.macosforge.org/downloads/SL/$latest" || abort "can't acquire $latest" "$cleanup"
        run "cp $latest /tmp/.install_dev/$latest"
    else
        run "cp /tmp/.install_dev/$latest ."
    fi
    run "hdiutil mount $latest" || abort "can't mount $latest at /Volumes/$(basename "$latest" .dmg)" "$cleanup"
    run "sudo installer -pkg /Volumes/$(basename "$latest" .dmg)/XQuartz.pkg -target /" || abort "installer failed" "$cleanup"
    run "$cleanup"
}

ensure_install_shell()
{
    local BINARY="$1"
    local INSTALLED="$(grep "$BINARY" /etc/shells)"
    if [[ "$INSTALLED" == "" ]]; then
        run "echo \"$BINARY\" | sudo tee -a /etc/shells"
    fi
}

step_install_bash() # bash
{
    ensure_homebrew_updated
    install_brew_formula bash

    BASH_BINARY="$(brew ls bash | grep '^.*/bin/.*bash$')"
    ensure_install_shell "$BASH_BINARY"

    HB_BASH_BINARY="/usr/local/bin/bash"
    ensure_install_shell "$HB_BASH_BINARY"
    run "chsh -s '$HB_BASH_BINARY' '$(whoami)'"
}

step_install_zsh() # zsh
{
    ensure_homebrew_updated
    install_brew_formula zsh
    install_brew_formula zsh-completions

    ZSH_BINARY="$(brew ls zsh | grep '^.*/bin/.*zsh$')"
    ensure_install_shell "$ZSH_BINARY"

    HB_ZSH_BINARY="/usr/local/bin/zsh"
    ensure_install_shell "$HB_ZSH_BINARY"
    run "chsh -s '$HB_ZSH_BINARY' '$(whoami)'"
}

step_install_tiddlywiki() # tiddlywiki
{
    ensure_homebrew_updated
    install_brew_formula node
    run "npm install -g tiddlywiki"
    run "mkdir -p $HOME/Library/LaunchDaemons"
    run "cd $HOME"
    if [[ -d notes ]]; then
        show "$(tput smul)WARNING$(tput sgr0): NOT overwriting '$HOME/notes', assuming tiddlywiki already installed there!"
    else
        run "tiddlywiki notes --init server"
    fi

    local TIDDLYWIKI_DOMAIN="org.tiddlywiki.server"
    show "Creating $HOME/Library/LaunchDaemons/org.tiddlywiki.server.plist..."
    if [[ $DRYRUN == 0 ]]; then
        cat >"$HOME/Library/LaunchDaemons/$TIDDLYWIKI_DOMAIN.plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>Label</key>
        <string>$TIDDLYWIKI_DOMAIN</string>

        <key>WorkingDirectory</key>
        <string>$HOME</string>

        <key>ProgramArguments</key>
        <array>
            <string>$(which tiddlywiki)</string>
            <string>notes</string>
            <string>--server</string>
        </array>

        <key>RunAtLoad</key>
        <true/>

        <key>KeepAlive</key>
        <true/>
    </dict>
</plist>
EOF
    fi

    show "Creating /etc/launchd.conf..."
    run "echo 'setenv PATH \"/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin\"' | sudo tee /etc/launchd.config"

    run "launchctl unload $HOME/Library/LaunchAgents/org.tiddlywiki.server.plist"
    run "launchctl load -w $HOME/Library/LaunchAgents/org.tiddlywiki.server.plist"

    show "TiddlyWiki setup at $HOME/notes"
    show "Server running at http://127.0.0.1:8080/"
}

################################################################################
# Main
################################################################################
if echo "$*" | egrep -q -- "--help|-h"; then
    usage
fi

OPTIND=1
LISTING=0
FORCE=0
ALL=0
DRYRUN=0
while getopts "lfd" opt; do
    case "$opt" in
        l) LISTING=1;;
        f) FORCE=1;;
        d) DRYRUN=1;;
    esac
done
shift $((OPTIND - 1))

# export force/dryrun settings to shell control variables (see ~/.shell_control)
export SC_FORCE="$FORCE"
export SC_DRYRUN="$DRYRUN"

if [[ $LISTING == 0 && -z "$1" ]]; then
    usage
fi

[[ $1 == all ]] && ALL=1

if [[ $LISTING == 0 ]]; then
    echo "$(tput bold)NOTE: This script is interactive, you will need to babysit it. Even in -f (force) mode you will still need to input your sudo password when asked for it.$(tput sgr0)"
    echo "$(tput bold)Prerequisite: Install 'Command Line Tools' from $(tput smul)http://developer.apple.com/downloads$(tput rmul) or from X Code preferences$(tput sgr0)"
fi

mkdir -p /tmp/.install_dev # download cache

# key; question; function
steps=("xcode;Check that Command Line Tools are installed;step_setup_xcode
brew;Upgrade/Install Homebrew formulas;step_install_homebrew
checkbrew;Check for additional or missing Homebrew packages;step_check_homebrew
python;Upgrade/Install Anaconda, pip packages, and conda packages;step_install_python
java;Check that java is installed (will prompt to install if not);step_check_java
gem;Upgrade/Install gem packages + rubygems-update package;step_install_gem
xquartz;Install latest XQuartz package;step_install_xquartz
bash;Install latest version of bash from Homebrew;step_install_bash
zsh;Install latest version of zsh from Homebrew;step_install_zsh
tiddlywiki;Install and setup latest TiddlyWiki from Homebrew;step_install_tiddlywiki")

IFS=$'\n'
let steps_taken=0
for step in ${steps[@]}; do
    key="$(echo $step | cut -d';' -f1)"
    question="$(echo $step | cut -d';' -f2)"
    function="$(echo $step | cut -d';' -f3)"

    if [[ $LISTING == 1 ]]; then
        echo "$key: $question"
        continue
    fi

    if [[ $ALL = 0 ]] && ! echo "$@" | egrep -q "\b$key\b"; then
        continue
    fi

    let steps_taken=$((steps_taken + 1))
    ask "[$key] $question?"
    if [[ "$REPLY" == "y" ]]; then
        show "Beginning step [$key]"
        eval "$function"
    fi
done

if [[ $LISTING == 0 && $steps_taken == 0 ]]; then
    abort "invalid step name(s): $*"
fi
