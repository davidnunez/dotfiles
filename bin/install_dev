#!/bin/bash

# Installs development environment on OS X machines.

################################################################################
# Settings
################################################################################
HOMEBREW_FORMULAS="ansible autoconf boost cloog cmake coreutils cppunit dmd doxygen fontconfig freetype gdbm gfortran ghostscript git git-flow gmp gnu-sed imagemagick isl jbig2dec jpeg libevent libmpc libpng libtiff libtool libyaml little-cms2 maven memcached mercurial mongodb mpfr ncftp node openssl openssl ossp-uuid pcre pidof pkg-config plotutils postgresql readline ruby s3cmd scons spark sqlite tclap unixodbc unrar watch wget xz yaml-cpp"
PIP_PACKAGES="bson pymongo fabric iniparse psycopg2 suds oauth2client google-api-python-client httplib2 tinycss termcolor"
CONDA_PACKAGES="dateutil pyzmq"
GEM_PACKAGES="cap_gun archive-tar-minitar bson bson_ext bundler bundler-unload childprocess cuba erector gem-wrappers jekyll jewelbox log4r lolcat mongo net-ldap rack rack-protection railsless-deploy rubygems-bundler rvm shotgun tiny_tds yajl-ruby capistrano"

################################################################################
# Utilities
################################################################################
function usage()
{
	echo "usage: $(basename $0) [-l | all | step-name ]"
	echo "options:"
	echo "    -h: show usage help"
	echo "    -l: list available step names"
	echo "    -d: dry-run"
	echo "    -f: force install, do not ask for any confirmation"
	echo "    all: executes all steps"
	echo "    step-name: execute only the given step"
	exit 0
}

function show()
{
	echo $'\e[1;34m==>\e[0m\e[31m' $1 $'\e[0m'
}

function run()
{
	show "$1"
	if [[ $DRYRUN == 0 ]]; then
		eval "$1"
		return $?
	else
		return 0
	fi
}

function abort()
{
	if [[ -n "$2" ]]; then
		run "$2"
	fi
	echo $'\e[1;31merror:' $1 $'\e[0m' >&2
	exit 1
}

function ask()
{
	if [[ $FORCE = 1 ]]; then
		REPLY='y'
		return 0
	fi
	echo -n $'\n\e[1;35m'
	read -p "$1 (y/n) [n] ... "
	echo -n $'\e[0;0m'
}

################################################################################
# Steps
################################################################################
function step_setup_xcode()
{
	export SELECT="select"
	if [[ -z "$(which xcode-$SELECT)" ]]; then
		abort "install Xcode Command Line Tools first"
	fi
	show "Xcode Command Line Tools properly installed."
}

function step_check_java()
{
	show "Checking if java's installed..."
	java -version
}

function step_check_homebrew()
{
	diff <(echo "$HOMEBREW_FORMULAS" | sort -u | tr ' ' '\n') <(brew ls -1 | sort -u) | grep '[<>]' | sort -u | sed "s@^>@added:  @g;s@<@missing:@g" | egrep -v "^missing:\s*openssl$" # we expect openssl to be unlinked
}

function install_brew_formula()
{
	if [[ -z "$(brew ls | grep $1)" ]]; then
		run "brew install $1"
	else
		show "brew formula $1 already installed"
	fi

	# force link the most recent versions
	run "brew unlink $1 && brew link --force --overwrite $1"
}

function ensure_homebrew_updated()
{
	if [[ -z "$(which brew)" ]]; then
		abort "please install Homebrew first"
	fi

	run "brew update"
	run "brew upgrade"
}

function step_install_homebrew()
{
	if [[ -z "$(which brew)" ]]; then
		show "installing homebrew..."
		ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
	else
		show "Homebrew already installed"
	fi

	if [[ -z "$(which brew)" ]]; then
		abort "failed to install Homebrew"
	fi

	ensure_homebrew_updated

	IFS=$" "
	for I in $HOMEBREW_FORMULAS; do
		install_brew_formula $I
	done

	# cmake's bundling utility fails in completely reasonable cases, the following steps are necessary
	run "chmod +w /usr/local/Cellar/freetds/*/lib/*.dylib 2>/dev/null"
	run "chmod +w /usr/local/Cellar/pcre/*/lib/*.dylib 2>/dev/null"
	
	# install glibtool and glibtoolize as the defaults
	run "ln -sf /usr/local/bin/glibtool /usr/local/bin/libtool"
	run "ln -sf /usr/local/bin/glibtoolize /usr/local/bin/libtoolize"

	# The gfortran formula doesn't symlink libraries into /usr/local/lib, do it manually.
	local LIBGFORTRAN="$(brew ls -v gfortran | grep libgfortran.a | egrep -m 1 -v "x86_64|i386")"
	if [[ $? == 0 ]]; then
		ln -sf "$LIBGFORTRAN" /usr/local/lib/.
	fi

	# install the git remote-hg helper
	ln -sf $(brew ls -v git | grep git-remote-hg) /usr/local/bin

	# unlink keg-only formulas which should not be not symlinked into /usr/local
	run "brew unlink openssl"
}

function step_install_python
{
	# enter existing anaconda environment if it's detected
	[[ -d "$HOME/anaconda/bin" ]] && export PATH="$HOME/anaconda/bin:$PATH"

	if type conda >/dev/null 2>&1; then
		conda update --yes --prefix "$HOME/anaconda" anaconda
	else
		curl_output=$(mktemp -d -t tmp.XXXXXXXXXX)
		trap "rm -rf $curl_output" EXIT

		latest="http://repo.continuum.io/archive/$(curl -s http://repo.continuum.io/archive/index.html | grep MacOSX-x86_64.sh | perl -nl -e 'm@<a.*? href="(.+)">(.+)</a@ig; print "$2\0$1"' | sort -nr | head -n 1 | cut -d '' -f2 | sed 's@./@@')"
		show "downloading $latest ..."
		curl -o "$curl_output/anaconda.sh" "$latest"
		bash "$curl_output/anaconda.sh" -b
		conda config --set changeps1 no # prevent conda from setting my PS1
		rm -f "$HOME/Desktop/Launcher.app" # get rid of Launcher.app on Desktop

		# enter anaconda environment now that it's installed
		export PATH="$HOME/anaconda/bin:$PATH"

		rm -rf "$curl_output"
	fi

	# Install python packages that don't come with Anaconda... yet!
	IFS=$" "
	for I in $PIP_PACKAGES; do
		run "pip install -U $I"
	done

	# Install conda packages that don't come pre-installed with Anaconda
	for I in $CONDA_PACKAGES; do
		run "conda install -f --yes $I"
		run "conda update -f --yes $I"
	done

	# Fix annoying ipython settings
	run "ipython profile create"
	run "perl -pi -e 's/.*confirm_exit.*/c.TerminalInteractiveShell.confirm_exit = False/' $HOME/.ipython/profile_default/ipython_config.py"
	run "perl -pi -e 's/.*display_banner.*/c.TerminalIPythonApp.display_banner = False/' $HOME/.ipython/profile_default/ipython_config.py"
}

function step_install_gem()
{
	run "yes | sudo gem install rubygems-update"
	run "yes | sudo update_rubygems"
	run "yes | sudo gem update -q --system"

	IFS=$" "
	for I in $GEM_PACKAGES; do
		run "yes | sudo gem update -q $I"
		if [[ -z "$(gem list $I | grep $I)" ]]; then
			run "yes | sudo gem install -q $I"
		fi
	done
}

function step_install_pyodbc()
{
	if [[ -n "$(pip freeze | grep pyodbc)" ]]; then
		show "a pyodbc package is already installed..."
		ask "Force re-install?"
		[[ "$REPLY" == "y" ]] || return
		run "yes | sudo pip uninstall pyodbc"
	fi

	local tempdir="$(mktemp -d -t tmp.XXXXXXXXXX)" || abort "can't create temp directory"
	local cleanup="rm -rf $tempdir"

	type git >/dev/null 2>&1 || abort "git must be installed first (brew install git)" "$cleanup"
	run "cd $tempdir" || abort "can't enter temp directory" "$cleanup"
	run "git clone https://code.google.com/p/pyodbc/" || abort "can't acquire source" "$cleanup"
	run "cd pyodbc" || abort "can't enter source directory" "$cleanup"

	# Theoretically we can just add odbc to the list, but that doesn't seem to work correctly,
	# so I've commented that line out and replaced it with a line that simply overrides to use unixODBC.
	# run "perl -pi -e \"s/append\\('iodbc'\\)/extend\\(['iodbc', 'odbc']\\)/g\" setup.py" || abort "can't apply patch to use unixODBC on OS X"
	run "perl -pi -e \"s/append\\('iodbc'\\)/extend\\(['odbc']\\)/g\" setup.py" || abort "can't apply patch to use unixODBC on OS X"

	run "sudo python setup.py build install" || abort "build or install step failed" "$cleanup"
	run "$cleanup"
}

function step_install_bison_3()
{
	if [[ -n "$(bison -V | head -n 1 | grep 3.0)" ]]; then
		show "a bison 3.0 is already installed..."
		ask "Force re-install?"
		[[ "$REPLY" == "y" ]] || return
	fi

	local tempdir="$(mktemp -d -t tmp.XXXXXXXXXX)" || abort "can't create temp directory"
	local cleanup="rm -rf $tempdir"
	run "cd $tempdir" || abort "can't enter temp directory" "$cleanup"
	if [[ ! -f /tmp/.install_dev/bison-3.0.tar.gz ]] ; then
		run "wget -c http://ftp.gnu.org/gnu/bison/bison-3.0.tar.gz" || abort "can't acquire source" "$cleanup"
		run "cp bison-3.0.tar.gz /tmp/.install_dev/bison-3.0.tar.gz"
	else
		run "cp /tmp/.install_dev/bison-3.0.tar.gz ."
	fi
	run "tar zfx bison-3.0.tar.gz" || abort "build step failed" "$cleanup"
	run "cd bison-3.0" || abort "build step failed" "$cleanup"
		run "./configure --prefix=/usr CFLAGS=-O3 && make" || abort "build step failed" "$cleanup"
		run "sudo make install" || abort "build step failed" "$cleanup"
	run "$cleanup"
}

function step_install_xquartz_275()
{
	if type Xquartz >/dev/null 2>&1; then
		show "a Xquartz is already installed..."
		ask "Force re-install?"
		[[ "$REPLY" == "y" ]] || return
	fi

	local tempdir="$(mktemp -d -t tmp.XXXXXXXXXX)" || abort "can't create temp directory"
	local cleanup="umount /Volumes/XQuartz-2.7.5; rm -rf $tempdir"
	run "cd $tempdir" || abort "can't enter temp directory" "$cleanup"
	if [[ ! -f /tmp/.install_dev/XQuartz-2.7.5.dmg ]] ; then
		run "wget -c http://xquartz.macosforge.org/downloads/SL/XQuartz-2.7.5.dmg" || abort "can't acquire XQuartz-2.7.5.dmg" "$cleanup"
		run "cp XQuartz-2.7.5.dmg /tmp/.install_dev/XQuartz-2.7.5.dmg"
	else
		run "cp /tmp/.install_dev/XQuartz-2.7.5.dmg ."
	fi
	run "hdiutil mount XQuartz-2.7.5.dmg" || abort "can't mount XQuartz-2.7.5.dmg on /Volumes/XQuartz-2.7.5" "$cleanup"
	run "sudo installer -pkg /Volumes/XQuartz-2.7.5/XQuartz.pkg -target /" || abort "installer failed" "$cleanup"
	run "$cleanup"
}

function step_install_mongo_c_driver_071()
{
	if [[ -f "/usr/local/lib/libmongoc.a" ]]; then
		show "a mongo-c-driver is already installed..."
		ask "Force re-install?"
		[[ "$REPLY" == "y" ]] || return
	fi

	local tempdir="$(mktemp -d -t tmp.XXXXXXXXXX)" || abort "can't create temp directory"
	local cleanup="rm -rf $tempdir"
	type scons >/dev/null 2>&1 || abort "scons must be installed first (brew install scons)" "$cleanup"
	run "cd $tempdir" || abort "can't enter temp directory" "$cleanup"
	run "git clone https://github.com/mongodb/mongo-c-driver.git" || abort "can't acquire source" "$cleanup"
	run "cd mongo-c-driver" || abort "can't enter source directory" "$cleanup"
	run "git checkout v0.7.1" || abort "build step failed" "$cleanup"
	run "scons" || abort "build step failed" "$cleanup"
	run "sudo make install" || abort "build step failed" "$cleanup"
	run "$cleanup"
}

function step_install_bash()
{
	ensure_homebrew_updated
	install_brew_formula bash

	local BASH_BINARY="$(brew ls bash | grep '^.*/bin/.*bash$')"
	local INSTALLED="$(grep "$BASH_BINARY" /etc/shells)"
	if [[ "$INSTALLED" == "" ]]; then
		run "echo \"$BASH_BINARY\" | sudo tee -a /etc/shells"
	fi

	show "Please set your terminal shell to \"$BASH_BINARY\""
}

function step_install_tiddlywiki()
{
	ensure_homebrew_updated
	install_brew_formula node
	run "npm install -g tiddlywiki"
	run "mkdir -p $HOME/Library/LaunchDaemons"
	run "cd $HOME"
	run "tiddlywiki notes --init server"

	local TIDDLYWIKI_DOMAIN="org.tiddlywiki.server"
	show "Creating $HOME/Library/LaunchDaemons/org.tiddlywiki.server.plist..."
	cat >"$HOME/Library/LaunchDaemons/$TIDDLYWIKI_DOMAIN.plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>Label</key>
		<string>$TIDDLYWIKI_DOMAIN</string>

		<key>WorkingDirectory</key>
		<string>$HOME</string>

		<key>ProgramArguments</key>
		<array>
			<string>$(which tiddlywiki)</string>
			<string>notes</string>
			<string>--server</string>
		</array>

		<key>RunAtLoad</key>
		<true/>

		<key>KeepAlive</key>
		<true/>
	</dict>
</plist>
EOF

	show "Creating /etc/launchd.conf..."
	sudo cat >/etc/launchd.conf <<EOF
setenv PATH "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"
EOF

	run "launchctl unload $HOME/Library/LaunchAgents/org.tiddlywiki.server.plist"
	run "launchctl load -w $HOME/Library/LaunchAgents/org.tiddlywiki.server.plist"

	show "Empty TiddlyWiki setup at $HOME/notes"
	show "Server running at http://127.0.0.1:8080/"
}

function step_install_ccache_319()
{
	if [[ -n "$(ccache -V | head -n 1 | grep 3.1.9)" ]]; then
		show "a ccache is already installed..."
		ask "Force re-install?"
		[[ "$REPLY" == "y" ]] || return
	fi

	local tempdir="$(mktemp -d -t tmp.XXXXXXXXXX)" || abort "can't create temp directory"
	local cleanup="rm -rf $tempdir"
	run "cd $tempdir" || abort "can't enter temp directory" "$cleanup"
	if [[ ! -f /tmp/.install_dev/ccache-3.1.9.tar.gz ]] ; then
		run "wget -c http://samba.org/ftp/ccache/ccache-3.1.9.tar.gz" || abort "can't acquire source" "$cleanup"
		run "cp ccache-3.1.9.tar.gz /tmp/.install_dev/ccache-3.1.9.tar.gz"
	else
		run "cp /tmp/.install_dev/ccache-3.1.9.tar.gz ."
	fi
	run "tar xvzf ccache-3.1.9.tar.gz" || abort "build step failed" "$cleanup"
	run "cd ccache-3.1.9" || abort "build step failed" "$cleanup"
	run "./configure CFLAGS=-O3 && make" || abort "build step failed" "$cleanup"
	run "sudo make install" || abort "build step failed" "$cleanup"
	run "sudo ln -fs /usr/local/bin/ccache /usr/local/bin/gcc" || abort "unable to symlink ccache" "$cleanup"
	run "sudo ln -fs /usr/local/bin/ccache /usr/local/bin/g++" || abort "unable to symlink ccache" "$cleanup"
	run "sudo ln -fs /usr/local/bin/ccache /usr/local/bin/c++" || abort "unable to symlink ccache" "$cleanup"
	run "sudo ln -fs /usr/local/bin/ccache /usr/local/bin/clang" || abort "unable to symlink ccache" "$cleanup"
	run "sudo ln -fs /usr/local/bin/ccache /usr/local/bin/clang++" || abort "unable to symlink ccache" "$cleanup"
	run "$cleanup"
}

################################################################################
# Main
################################################################################
OPTIND=1
LISTING=0
FORCE=0
ALL=0
DRYRUN=0
while getopts "hlfd" opt; do
	case "$opt" in
		h) usage;;
		l) LISTING=1;;
		f) FORCE=1;;
		d) DRYRUN=1;;
	esac
done
shift $((OPTIND - 1))

if [[ $LISTING == 0 && -z "$1" ]]; then
	usage
fi

[[ $1 == all ]] && ALL=1

echo "$(tput bold)NOTE: This script is interactive, you will need to babysit it. Even in -f (force) mode you will still need to input your sudo password when asked for it.$(tput sgr0)"

if [[ $LISTING == 0 ]]; then
	echo "$(tput bold)Prerequisite: Install \"Command Line Tools\" from $(tput smul)http://developer.apple.com/downloads$(tput rmul) or X Code preferences$(tput sgr0)"
	ask "Are the \"Command Line Tools\" installed?"
	[[ "$REPLY" == "y" ]] || exit 1
	mkdir -p /tmp/.install_dev # download cache
fi

# key; question; function
steps=("xcode;Check that Command Line Tools are installed?;step_setup_xcode
brew;Upgrade/Install Homebrew, formulas: $HOMEBREW_FORMULAS?;step_install_homebrew
checkbrew;Check for additional or missing Homebrew packages?;step_check_homebrew
python;Upgrade/Install Anaconda, pip packages: $PIP_PACKAGES, conda packages: $CONDA_PACKAGES?;step_install_python
java;Check that java is installed (will prompt to install if not);step_check_java
gem;Upgrade/Install gem packages: rubygems-update $GEM_PACKAGES?;step_install_gem
pyodbc;Install pyodbc (patched for unixODBC on OS X)?;step_install_pyodbc
bison;Install bison 3.0 from source?;step_install_bison_3
XQuartz;Install XQuartz 2.7.5 package?;step_install_xquartz_275
mongo;Install mongo-c-driver v0.7.1 from source?;step_install_mongo_c_driver_071
bash;Install latest version of bash from Homebrew?;step_install_bash
tiddlywiki;Install and setup latest TiddlyWiki from Homebrew?;step_install_tiddlywiki
ccache;Install ccache 3.1.9 from source?;step_install_ccache_319")

IFS=$'\n'
let steps_taken=0
for step in $steps; do
	key="$(echo $step | cut -d';' -f1)"
	question="$(echo $step | cut -d';' -f2)"
	function="$(echo $step | cut -d';' -f3)"

	if [[ $LISTING == 1 ]]; then
		echo "$(tput bold)$key$(tput sgr0)	=> $question"
		continue
	fi

	if [[ $ALL == 0 && -z "$(echo $@ | egrep "\b$key\b")" ]]; then
		continue
	fi

	let steps_taken=$(($steps_taken + 1))
	ask "[$key] $question"
	if [[ "$REPLY" == "y" ]]; then
		show "Beginning step [$key]"
		eval "$function"
	fi
done

if [[ $LISTING == 0 && $steps_taken == 0 ]]; then
	abort "invalid step name(s): $@"
fi

exit 0
